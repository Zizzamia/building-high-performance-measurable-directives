"use strict";
Object.defineProperties(module.exports, {
  ControlValueAccessor: {get: function() {
      return ControlValueAccessor;
    }},
  ControlDirectiveBase: {get: function() {
      return ControlDirectiveBase;
    }},
  ControlNameDirective: {get: function() {
      return ControlNameDirective;
    }},
  ControlDirective: {get: function() {
      return ControlDirective;
    }},
  ControlGroupDirective: {get: function() {
      return ControlGroupDirective;
    }},
  NewControlGroupDirective: {get: function() {
      return NewControlGroupDirective;
    }},
  FormDirectives: {get: function() {
      return FormDirectives;
    }},
  __esModule: {value: true}
});
var __moduleName = "angular2/src/forms/directives";
var $__rtts_95_assert_47_rtts_95_assert__,
    $__angular2_47_core__,
    $__angular2_47_src_47_facade_47_dom__,
    $__angular2_47_src_47_facade_47_lang__,
    $__angular2_47_src_47_facade_47_collection__,
    $__angular2_47_src_47_forms_47_model__;
var assert = ($__rtts_95_assert_47_rtts_95_assert__ = require("rtts_assert/rtts_assert"), $__rtts_95_assert_47_rtts_95_assert__ && $__rtts_95_assert_47_rtts_95_assert__.__esModule && $__rtts_95_assert_47_rtts_95_assert__ || {default: $__rtts_95_assert_47_rtts_95_assert__}).assert;
var $__1 = ($__angular2_47_core__ = require("angular2/core"), $__angular2_47_core__ && $__angular2_47_core__.__esModule && $__angular2_47_core__ || {default: $__angular2_47_core__}),
    Template = $__1.Template,
    Component = $__1.Component,
    Decorator = $__1.Decorator,
    NgElement = $__1.NgElement,
    Ancestor = $__1.Ancestor,
    onChange = $__1.onChange;
var DOM = ($__angular2_47_src_47_facade_47_dom__ = require("angular2/src/facade/dom"), $__angular2_47_src_47_facade_47_dom__ && $__angular2_47_src_47_facade_47_dom__.__esModule && $__angular2_47_src_47_facade_47_dom__ || {default: $__angular2_47_src_47_facade_47_dom__}).DOM;
var $__3 = ($__angular2_47_src_47_facade_47_lang__ = require("angular2/src/facade/lang"), $__angular2_47_src_47_facade_47_lang__ && $__angular2_47_src_47_facade_47_lang__.__esModule && $__angular2_47_src_47_facade_47_lang__ || {default: $__angular2_47_src_47_facade_47_lang__}),
    isBlank = $__3.isBlank,
    isPresent = $__3.isPresent,
    CONST = $__3.CONST;
var $__4 = ($__angular2_47_src_47_facade_47_collection__ = require("angular2/src/facade/collection"), $__angular2_47_src_47_facade_47_collection__ && $__angular2_47_src_47_facade_47_collection__.__esModule && $__angular2_47_src_47_facade_47_collection__ || {default: $__angular2_47_src_47_facade_47_collection__}),
    StringMapWrapper = $__4.StringMapWrapper,
    ListWrapper = $__4.ListWrapper;
var $__5 = ($__angular2_47_src_47_forms_47_model__ = require("./model"), $__angular2_47_src_47_forms_47_model__ && $__angular2_47_src_47_forms_47_model__.__esModule && $__angular2_47_src_47_forms_47_model__ || {default: $__angular2_47_src_47_forms_47_model__}),
    ControlGroup = $__5.ControlGroup,
    Control = $__5.Control;
var ControlGroupDirectiveBase = function ControlGroupDirectiveBase() {};
($traceurRuntime.createClass)(ControlGroupDirectiveBase, {
  addDirective: function(directive) {},
  findControl: function(name) {
    assert.argumentTypes(name, assert.type.string);
    return assert.returnType((null), Control);
  }
}, {});
Object.defineProperty(ControlGroupDirectiveBase.prototype.findControl, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
var ControlValueAccessor = function ControlValueAccessor() {};
($traceurRuntime.createClass)(ControlValueAccessor, {
  readValue: function(el) {},
  writeValue: function(el, value) {}
}, {});
Object.defineProperty(ControlValueAccessor, "annotations", {get: function() {
    return [new CONST()];
  }});
var DefaultControlValueAccessor = function DefaultControlValueAccessor() {
  $traceurRuntime.superConstructor($DefaultControlValueAccessor).call(this);
};
var $DefaultControlValueAccessor = DefaultControlValueAccessor;
($traceurRuntime.createClass)(DefaultControlValueAccessor, {
  readValue: function(el) {
    return DOM.getValue(el);
  },
  writeValue: function(el, value) {
    DOM.setValue(el, value);
  }
}, {}, ControlValueAccessor);
Object.defineProperty(DefaultControlValueAccessor, "annotations", {get: function() {
    return [new CONST()];
  }});
var CheckboxControlValueAccessor = function CheckboxControlValueAccessor() {
  $traceurRuntime.superConstructor($CheckboxControlValueAccessor).call(this);
};
var $CheckboxControlValueAccessor = CheckboxControlValueAccessor;
($traceurRuntime.createClass)(CheckboxControlValueAccessor, {
  readValue: function(el) {
    return assert.returnType((DOM.getChecked(el)), assert.type.boolean);
  },
  writeValue: function(el, value) {
    assert.argumentTypes(el, assert.type.any, value, assert.type.boolean);
    DOM.setChecked(el, value);
  }
}, {}, ControlValueAccessor);
Object.defineProperty(CheckboxControlValueAccessor, "annotations", {get: function() {
    return [new CONST()];
  }});
Object.defineProperty(CheckboxControlValueAccessor.prototype.writeValue, "parameters", {get: function() {
    return [[], [assert.type.boolean]];
  }});
var controlValueAccessors = {
  "checkbox": new CheckboxControlValueAccessor(),
  "text": new DefaultControlValueAccessor()
};
function controlValueAccessorFor(controlType) {
  assert.argumentTypes(controlType, assert.type.string);
  var accessor = StringMapWrapper.get(controlValueAccessors, controlType);
  if (isPresent(accessor)) {
    return assert.returnType((accessor), ControlValueAccessor);
  } else {
    return assert.returnType((StringMapWrapper.get(controlValueAccessors, "text")), ControlValueAccessor);
  }
}
Object.defineProperty(controlValueAccessorFor, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
var ControlDirectiveBase = function ControlDirectiveBase(groupDecorator, el) {
  assert.argumentTypes(groupDecorator, assert.type.any, el, NgElement);
  this._groupDecorator = groupDecorator;
  this._el = el;
};
($traceurRuntime.createClass)(ControlDirectiveBase, {
  _initialize: function() {
    var $__6 = this;
    if (isBlank(this.valueAccessor)) {
      this.valueAccessor = controlValueAccessorFor(this.type);
    }
    this._groupDecorator.addDirective(this);
    this._updateDomValue();
    DOM.on(this._el.domElement, "change", (function(_) {
      return $__6._updateControlValue();
    }));
  },
  _updateDomValue: function() {
    this.valueAccessor.writeValue(this._el.domElement, this._control().value);
  },
  _updateControlValue: function() {
    this._control().value = this.valueAccessor.readValue(this._el.domElement);
  },
  _control: function() {
    return this._groupDecorator.findControl(this.controlName);
  }
}, {});
Object.defineProperty(ControlDirectiveBase, "parameters", {get: function() {
    return [[], [NgElement]];
  }});
var ControlNameDirective = function ControlNameDirective(groupDecorator, el) {
  assert.argumentTypes(groupDecorator, ControlGroupDirective, el, NgElement);
  $traceurRuntime.superConstructor($ControlNameDirective).call(this, groupDecorator, el);
};
var $ControlNameDirective = ControlNameDirective;
($traceurRuntime.createClass)(ControlNameDirective, {onChange: function(_) {
    this._initialize();
  }}, {}, ControlDirectiveBase);
Object.defineProperty(ControlNameDirective, "annotations", {get: function() {
    return [new Decorator({
      lifecycle: [onChange],
      selector: '[control-name]',
      bind: {
        'controlName': 'control-name',
        'type': 'type'
      }
    })];
  }});
Object.defineProperty(ControlNameDirective, "parameters", {get: function() {
    return [[ControlGroupDirective, new Ancestor()], [NgElement]];
  }});
var ControlDirective = function ControlDirective(groupDecorator, el) {
  assert.argumentTypes(groupDecorator, NewControlGroupDirective, el, NgElement);
  $traceurRuntime.superConstructor($ControlDirective).call(this, groupDecorator, el);
};
var $ControlDirective = ControlDirective;
($traceurRuntime.createClass)(ControlDirective, {onChange: function(_) {
    this._initialize();
  }}, {}, ControlDirectiveBase);
Object.defineProperty(ControlDirective, "annotations", {get: function() {
    return [new Decorator({
      lifecycle: [onChange],
      selector: '[control]',
      bind: {
        'controlName': 'control',
        'type': 'type'
      }
    })];
  }});
Object.defineProperty(ControlDirective, "parameters", {get: function() {
    return [[NewControlGroupDirective, new Ancestor()], [NgElement]];
  }});
var ControlGroupDirective = function ControlGroupDirective() {
  $traceurRuntime.superConstructor($ControlGroupDirective).call(this);
  this._directives = ListWrapper.create();
};
var $ControlGroupDirective = ControlGroupDirective;
($traceurRuntime.createClass)(ControlGroupDirective, {
  set controlGroup(controlGroup) {
    this._controlGroup = controlGroup;
    ListWrapper.forEach(this._directives, (function(cd) {
      return cd._updateDomValue();
    }));
  },
  addDirective: function(c) {
    assert.argumentTypes(c, ControlNameDirective);
    ListWrapper.push(this._directives, c);
  },
  findControl: function(name) {
    assert.argumentTypes(name, assert.type.string);
    return assert.returnType((this._controlGroup.controls[name]), Control);
  }
}, {}, ControlGroupDirectiveBase);
Object.defineProperty(ControlGroupDirective, "annotations", {get: function() {
    return [new Decorator({
      selector: '[control-group]',
      bind: {'controlGroup': 'control-group'}
    })];
  }});
Object.defineProperty(Object.getOwnPropertyDescriptor(ControlGroupDirective.prototype, "controlGroup").set, "parameters", {get: function() {
    return [[ControlGroup]];
  }});
Object.defineProperty(ControlGroupDirective.prototype.addDirective, "parameters", {get: function() {
    return [[ControlNameDirective]];
  }});
Object.defineProperty(ControlGroupDirective.prototype.findControl, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
var NewControlGroupDirective = function NewControlGroupDirective() {
  $traceurRuntime.superConstructor($NewControlGroupDirective).call(this);
  this._directives = ListWrapper.create();
};
var $NewControlGroupDirective = NewControlGroupDirective;
($traceurRuntime.createClass)(NewControlGroupDirective, {
  set initData(value) {
    this._initData = value;
  },
  addDirective: function(c) {
    assert.argumentTypes(c, ControlDirective);
    ListWrapper.push(this._directives, c);
    this._controlGroup = null;
  },
  findControl: function(name) {
    assert.argumentTypes(name, assert.type.string);
    if (isBlank(this._controlGroup)) {
      this._controlGroup = this._createControlGroup();
    }
    return assert.returnType((this._controlGroup.controls[name]), Control);
  },
  _createControlGroup: function() {
    var $__6 = this;
    var controls = ListWrapper.reduce(this._directives, (function(memo, cd) {
      var initControlValue = $__6._initData[cd.controlName];
      memo[cd.controlName] = new Control(initControlValue);
      return memo;
    }), {});
    return assert.returnType((new ControlGroup(controls)), ControlGroup);
  },
  get value() {
    return this._controlGroup.value;
  }
}, {}, ControlGroupDirectiveBase);
Object.defineProperty(NewControlGroupDirective, "annotations", {get: function() {
    return [new Component({
      selector: '[new-control-group]',
      bind: {'initData': 'new-control-group'}
    }), new Template({inline: '<content>'})];
  }});
Object.defineProperty(NewControlGroupDirective.prototype.addDirective, "parameters", {get: function() {
    return [[ControlDirective]];
  }});
Object.defineProperty(NewControlGroupDirective.prototype.findControl, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
var FormDirectives = [ControlGroupDirective, ControlNameDirective, ControlDirective, NewControlGroupDirective];

//# sourceMappingURL=/Users/tbosch/projects/angular2/modules/angular2/src/forms/directives.map

//# sourceMappingURL=./directives.map